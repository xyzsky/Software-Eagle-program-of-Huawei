<!--
 * @Author: xyz
 * @Date: 2022-06-02 16:37:53
 * @LastEditTime: 2022-06-02 16:41:08
 * @LastEditors: xyz
 * @Description: 基础知识
 * @FilePath: \C语言\basic.md
-->
##  变量

1. 基本变量类型和占用内存大小：
char(1)  short(2)  int(4) long(4) float(4) double(4)
2. 基本变量类型中，可以添加unsigned
   - 可以加： char, short, int, long
   - 不可以加：float, double
3. 变量类型定义

```c
// p1 是一个指针，它指向一个int类型
int *p1;
// p2 是一个常量指针，它指向一个const int类型, p2 可以指向其它地址
const int *p2;
// p3 是一个常量指针，同p2
int const *p3;
// p4 是一个指针常量，指向一个int类型，p4不能再指向其它地址
int *const p4;
// p5 是一个指向常量的指针常量，const同时修饰类型和指针，p5和p5指向地址的值不能修改
const int *const p5;
// p6表示一个数组，数组里面存放int类型的值
int p6[2];
// p7是一个指针，指向一个int类型；p8是一个int类型的变量
int *p7, p8;

```

4. 数据模型

   LP32 , ILP32, LP64, LLP64, ILP64

![image-20220602170145176](X:\Software-Eagle-program-of-Huawei\C语言\image\image-20220602170145176.png)

5. 32位和64位下基本数据类型的字节长度

![image-20220602165853916](X:\Software-Eagle-program-of-Huawei\C语言\image\image-20220602165853916.png)





## 表达式



**编译器总是尽量多的去匹配操作符！**

```c
int m = 5;
int n = 3;
int k = m+++-+-+--n;
printf("m=%d, n=%d, k=%d", m, n, k);
// m = 6, n = 2, k = 7;
```



**类型自动转换规则：**

1. 参与运算的类型不同，先转换为相同的类型再运算
2. 数据类型向数据长度增长的方向转换，char->short->int->unsigned int->long
3. 所有float都会先转换为double再进行运算，哪怕只有一个float
4. 赋值运算时，赋值号右边的类型向左边的类型进行转换
5. 浮点数和整形数，整型数向浮点数转换
6. 在表达式中，如果char和short类型的值进行运算，无论char和short有无符号，结果都会自动转换成int
7. 如果char或short与int类型进行计算，结果和int类型相同。即：如果int是有符号，结果就是带符号的，如果int是无符号的，结果就是无符号的。

**数据类型排序**

long double, double, float, unsigned long long, long long, unsigned long, long , unsigned int , int , unsigned short, short, unsigned char, char

>  同一类型，有符号数和无符号数进行运算，有符号数向无符号数转变



**反码补码原码**：

计算机在底层存储数据的时候，一律存储的是**“二进制的补码形式”**

原码 ：最高位是符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制。

反码：正数的反码与原码一致，负数的反码是对原码按位取反，只是最高位（符号位）不变。 

补码：正数的补码与原码一致，负数的补码是对原码按位取反加1，符号位不变。

补码变成原码的方式是：正数的补码与原码一致，负数的补码按位取反加1，符号位不变

反码变成原码的方式是：正数的反码与原码一致，负数的补码按位取反，符号位不变

> 对于一个正数来说：二进制原码、反码、补码是同一个，`完全相同`。
>
> 对于一个负数来说：对应的二进制**原码**：10000001，
>
> ​								   对应的二进制**反码**（`符号位不变，其它位取反`）**：11111110，**
>
> ​							       **对应的二进制**补码（`反码+1`）：11111111

- 一个数与自身的取反值相加等于-1





## 宏

**常用功能**

1. 常量替换
2. 类型定义
3. 函数宏
4. 防止头文件重复包含
5. 内定调试宏

```c
//1. 常量替换
#define MAX_CLASS 10
#define MAX_PEOPLE 100
//2. 类型定义
#define MAX_STUDENTS_PER_CLASS(MAX_PEOPLE / MAX_CLASS)
//3. 宏函数
#define MAX(x,y) (((x) > (y)) ? (x) : (y))
//4. 防止头文件重复包含

//5. 内定调试宏
功能描述
 
#define WARING(str) printf("%s, line = %d, file=%s, data=%s, time=%s", str, __LINE__, __FILE__, __DATE__, __TIME__)

int main() 
{
   WARING("test");
   return 0;
}
```



不足：

- 宏在符号表中不存在，所有宏函数无法打热补丁，在vs或者单板调试过程中，无法引用
- 程序的代码空间增大
- 宏函数单步调试时无法进入
- 宏常量没有数据类型，编译器不能再编译时进行深入类型检查

优点：

- 宏函数效率较高
- 数组大小，只能再编译阶段确定，只能用宏



## 枚举



枚举的大小和**编译器、编译选项**有关系，具体大小无法统一确定

建议：

1. 不要使用枚举的大小
2. 枚举的值不要超过32位

基本规则：

1. 枚举第一个值如果没有定义，那么从0开始
2. 枚举的值如果指定，那么就是指定值
3. 枚举的值如果没有指定，那么就是其上一个值+1
4. 同一个枚举下面的值可以相同

> 考虑到不同编译器对枚举大小实现不同，建议枚举值不要超过32位

使用建议：

1. 尽量不要指定枚举值的大小
2. 再结构体中，使用枚举字段需要谨慎
3. 枚举间尽量不要强制转换（无法检查）